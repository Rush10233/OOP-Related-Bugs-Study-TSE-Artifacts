{
          tree lambda_stack = NULL_TREE;
          tree init = NULL_TREE;

    
          /* If we are in a lambda function, we can move out until we hit:
               1. a non-lambda function or NSDMI,

    				      lambda_stack);
    
    	  tree closure = LAMBDA_EXPR_CLOSURE (tlambda);

    	  tree containing_function
    	    = decl_function_context (TYPE_NAME (closure));
    

    	      /* Lambda in an NSDMI.  We don't have a function to look up
    		 'this' in, but we can find (or rebuild) the fake one from
    		 inject_this_parameter.  */

    		/* If we're parsing a lambda in a non-local class,
    		   we can find the fake 'this' in scope_chain.  */
    		init = scope_chain->x_current_class_ptr;

{
          tree lambda_stack = NULL_TREE;
          tree init = NULL_TREE;

    
          /* If we are in a lambda function, we can move out until we hit:
               1. a non-lambda function or NSDMI,

    				      lambda_stack);
    
    	  tree closure = LAMBDA_EXPR_CLOSURE (tlambda);

    	  tree containing_function
    	    = decl_function_context (TYPE_NAME (closure));
    

    	      /* Lambda in an NSDMI.  We don't have a function to look up
    		 'this' in, but we can find (or rebuild) the fake one from
    		 inject_this_parameter.  */

    		/* If we're parsing a lambda in a non-local class,
    		   we can find the fake 'this' in scope_chain.  */
    		init = scope_chain->x_current_class_ptr;

{
          tree lambda_stack = NULL_TREE;
          tree init = NULL_TREE;

    
          /* If we are in a lambda function, we can move out until we hit:
               1. a non-lambda function or NSDMI,

    				      lambda_stack);
    
    	  tree closure = LAMBDA_EXPR_CLOSURE (tlambda);

    	  tree containing_function
    	    = decl_function_context (TYPE_NAME (closure));
    

    	      /* Lambda in an NSDMI.  We don't have a function to look up
    		 'this' in, but we can find (or rebuild) the fake one from
    		 inject_this_parameter.  */

    		/* If we're parsing a lambda in a non-local class,
    		   we can find the fake 'this' in scope_chain.  */
    		init = scope_chain->x_current_class_ptr;

{
          tree lambda_stack = NULL_TREE;
          tree init = NULL_TREE;

    
          /* If we are in a lambda function, we can move out until we hit:
               1. a non-lambda function or NSDMI,

    				      lambda_stack);
    
    	  tree closure = LAMBDA_EXPR_CLOSURE (tlambda);

    	  tree containing_function
    	    = decl_function_context (TYPE_NAME (closure));
    

    	      /* Lambda in an NSDMI.  We don't have a function to look up
    		 'this' in, but we can find (or rebuild) the fake one from
    		 inject_this_parameter.  */

    		/* If we're parsing a lambda in a non-local class,
    		   we can find the fake 'this' in scope_chain.  */
    		init = scope_chain->x_current_class_ptr;

