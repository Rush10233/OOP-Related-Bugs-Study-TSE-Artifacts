extern bool push_tinst_level_loc                (tree, tree, location_t);
    extern void pop_tinst_level                     (void);
    extern struct tinst_level *outermost_tinst_level(void);

    extern void init_template_processing		(void);
    extern void print_template_statistics		(void);
    bool template_template_parameter_p		(const_tree);

    	      check_no_redeclaration_friend_default_args
    		(old_result, new_result);
    	    }

    
    	  check_default_args (newdecl);
    

          if (LANG_DECL_HAS_MIN (newdecl))
    	{
    	  DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);

    	    {
    	      new_template_info = DECL_TEMPLATE_INFO (newdecl);
    	      if (DECL_TEMPLATE_INSTANTIATION (olddecl)
    		  && DECL_TEMPLATE_SPECIALIZATION (newdecl))
    		/* Remember the presence of explicit specialization args.  */
    		TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))
    		  = TINFO_USED_TEMPLATE_ID (new_template_info);
    	    }

    	  else
    	    DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);
    	}

      return level;
    }
    

    /* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the
       vector of template arguments, as for tsubst.
    

          /* This special case arises when we have something like this:
    
    	 template <class T> struct S {

    	 };
    
    	 Here, the DECL_TI_TEMPLATE for the friend declaration

if (LANG_DECL_HAS_MIN (newdecl))
    	{
    	  DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);

    	    {
    	      new_template_info = DECL_TEMPLATE_INFO (newdecl);
    	      if (DECL_TEMPLATE_INSTANTIATION (olddecl)
    		  && DECL_TEMPLATE_SPECIALIZATION (newdecl))
    		/* Remember the presence of explicit specialization args.  */
    		TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))
    		  = TINFO_USED_TEMPLATE_ID (new_template_info);

    	    }

    	}
    
          if (DECL_DECLARES_FUNCTION_P (newdecl))

if (LANG_DECL_HAS_MIN (newdecl))
    	{
    	  DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);

    	    {
    	      new_template_info = DECL_TEMPLATE_INFO (newdecl);
    	      if (DECL_TEMPLATE_INSTANTIATION (olddecl)
    		  && DECL_TEMPLATE_SPECIALIZATION (newdecl))
    		/* Remember the presence of explicit specialization args.  */
    		TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))
    		  = TINFO_USED_TEMPLATE_ID (new_template_info);

    	    }

    	}
    
          if (DECL_DECLARES_FUNCTION_P (newdecl))

extern bool push_tinst_level_loc                (tree, tree, location_t);
    extern void pop_tinst_level                     (void);
    extern struct tinst_level *outermost_tinst_level(void);

    extern void init_template_processing		(void);
    extern void print_template_statistics		(void);
    bool template_template_parameter_p		(const_tree);

    	      merge_default_template_args (new_parms, old_parms,
    					   /*class_p=*/false);
    	    }

    
    	  check_default_args (newdecl);
    

          if (LANG_DECL_HAS_MIN (newdecl))
    	{
    	  DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);

    	    {
    	      new_template_info = DECL_TEMPLATE_INFO (newdecl);
    	      if (DECL_TEMPLATE_INSTANTIATION (olddecl)
    		  && DECL_TEMPLATE_SPECIALIZATION (newdecl))
    		/* Remember the presence of explicit specialization args.  */
    		TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))
    		  = TINFO_USED_TEMPLATE_ID (new_template_info);
    	    }

    	  else
    	    DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);
    	}

      return level;
    }
    

    /* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the
       vector of template arguments, as for tsubst.
    

          /* This special case arises when we have something like this:
    
    	 template <class T> struct S {

    	 };
    
    	 Here, the DECL_TI_TEMPLATE for the friend declaration

if (LANG_DECL_HAS_MIN (newdecl))
    	{
    	  DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);

    	    {
    	      new_template_info = DECL_TEMPLATE_INFO (newdecl);
    	      if (DECL_TEMPLATE_INSTANTIATION (olddecl)
    		  && DECL_TEMPLATE_SPECIALIZATION (newdecl))
    		/* Remember the presence of explicit specialization args.  */
    		TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))
    		  = TINFO_USED_TEMPLATE_ID (new_template_info);

    	    }

    	}
    
          if (DECL_DECLARES_FUNCTION_P (newdecl))

extern bool push_tinst_level_loc                (tree, tree, location_t);
    extern void pop_tinst_level                     (void);
    extern struct tinst_level *outermost_tinst_level(void);

    extern void init_template_processing		(void);
    extern void print_template_statistics		(void);
    bool template_template_parameter_p		(const_tree);

    	      merge_default_template_args (new_parms, old_parms,
    					   /*class_p=*/false);
    	    }

    
    	  check_default_args (newdecl);
    

          if (LANG_DECL_HAS_MIN (newdecl))
    	{
    	  DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);

    	    {
    	      new_template_info = DECL_TEMPLATE_INFO (newdecl);
    	      if (DECL_TEMPLATE_INSTANTIATION (olddecl)
    		  && DECL_TEMPLATE_SPECIALIZATION (newdecl))
    		/* Remember the presence of explicit specialization args.  */
    		TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))
    		  = TINFO_USED_TEMPLATE_ID (new_template_info);
    	    }

    	  else
    	    DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);
    	}

      return level;
    }
    

    /* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the
       vector of template arguments, as for tsubst.
    

          /* This special case arises when we have something like this:
    
    	 template <class T> struct S {

    	 };
    
    	 Here, the DECL_TI_TEMPLATE for the friend declaration

